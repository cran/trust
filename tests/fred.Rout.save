
R : Copyright 2005, The R Foundation for Statistical Computing
Version 2.2.0 beta (2005-09-26 r35681)
ISBN 3-900051-07-0

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for a HTML browser interface to help.
Type 'q()' to quit R.

> 
>  library(trust)
> 
>  ##### four-way contingency table with all two-way interactions
> 
>  d <- c(3, 4, 5, 6)
>  n <- 1000
> 
>  ##### model matrix
>  m <- NULL
>  for (i in 1:d[1]) {
+      for (j in 1:d[2]) {
+          mfoo <- array(0, dim = d)
+          mfoo[i, j, , ] <- 1
+          mfoo <- as.vector(mfoo)
+          m <- cbind(m, mfoo)
+      }
+  }
>  for (i in 1:d[1]) {
+      for (j in 1:d[3]) {
+          mfoo <- array(0, dim = d)
+          mfoo[i, , j, ] <- 1
+          mfoo <- as.vector(mfoo)
+          m <- cbind(m, mfoo)
+      }
+  }
>  for (i in 1:d[1]) {
+      for (j in 1:d[4]) {
+          mfoo <- array(0, dim = d)
+          mfoo[i, , , j] <- 1
+          mfoo <- as.vector(mfoo)
+          m <- cbind(m, mfoo)
+      }
+  }
>  for (i in 1:d[2]) {
+      for (j in 1:d[3]) {
+          mfoo <- array(0, dim = d)
+          mfoo[ , i, j, ] <- 1
+          mfoo <- as.vector(mfoo)
+          m <- cbind(m, mfoo)
+      }
+  }
>  for (i in 1:d[2]) {
+      for (j in 1:d[4]) {
+          mfoo <- array(0, dim = d)
+          mfoo[ , i, , j] <- 1
+          mfoo <- as.vector(mfoo)
+          m <- cbind(m, mfoo)
+      }
+  }
>  for (i in 1:d[3]) {
+      for (j in 1:d[4]) {
+          mfoo <- array(0, dim = d)
+          mfoo[ , , i, j] <- 1
+          mfoo <- as.vector(mfoo)
+          m <- cbind(m, mfoo)
+      }
+  }
>  dimnames(m) <- NULL
>  foo <- qr(m)
>  m <- m[ , foo$pivot[seq(1, foo$rank)]]
> 
>  ##### true parameter value
>  set.seed(42)
>  theta.true <- 0.25 * rnorm(ncol(m))
>  theta.true <- round(theta.true, 5)
> 
>  ##### simulate data
>  eta <- as.numeric(m %*% theta.true)
>  p <- exp(eta)
>  p <- p / sum(p)
>  x <- sample(nrow(m), n, replace = TRUE, prob = p)
Warning message:
Walker's alias method used: results are different from R < 2.2.0 
>  x <- tabulate(x, nbins = nrow(m))
> 
>  ##### save data
>  iffy <- try(read.table("fred.txt"), silent = TRUE)
>  if (inherits(iffy, "try-error")) {
+      data <- data.frame(x = x, m = m)
+      write.table(data, file = "fred.txt", row.names = FALSE)
+  }
>  data <- read.table(file = "fred.txt", header = TRUE)
>  x <- data$x
>  data$x <- NULL
>  m <- as.matrix(data)
>  dimnames(m) <- NULL
> 
>  ##### log likelihood
>  objfun <- function(theta) {
+      eta <- as.numeric(m %*% theta)
+      p <- exp(eta)
+      f <- sum(x * eta - p)
+      g <- as.numeric(t(x - p) %*% m)
+      B <- sweep(- m, 1, p, "*")
+      B <- t(m) %*% B
+      list(value = f, gradient = g, hessian = B)
+  }
> 
>  ##### check it
>  sally <- objfun(theta.true)
>  epsilon <- 1e-8
>  mygrad <- double(length(theta.true))
>  for (i in 1:length(mygrad)) {
+      theta.eps <- theta.true
+      theta.eps[i] <- theta.true[i] + epsilon
+      sally.eps <- objfun(theta.eps)
+      mygrad[i] <- (sally.eps$value - sally$value) / epsilon
+  }
>  all.equal(sally$gradient, mygrad, tolerance = length(mygrad) * epsilon)
[1] TRUE
>  myhess <- matrix(NA, length(theta.true), length(theta.true))
>  for (i in 1:length(mygrad)) {
+      theta.eps <- theta.true
+      theta.eps[i] <- theta.true[i] + epsilon
+      sally.eps <- objfun(theta.eps)
+      myhess[i, ] <- (sally.eps$gradient - sally$gradient) / epsilon
+  }
>  all.equal(sally$hessian, myhess, tolerance = length(mygrad) * epsilon)
[1] TRUE
> 
>  fred <- trust(objfun, theta.true, 1, sqrt(ncol(m)), minimize = FALSE)
> 
>  fran <- glm.fit(m, x, family = poisson(), intercept = FALSE)
> 
>  all.equal(fran$coefficients, fred$argument)
[1] TRUE
> 
>  fred <- trust(objfun, rep(0, length(theta.true)), 1, sqrt(ncol(m)),
+      minimize = FALSE, blather = TRUE)
>  fred$converged
[1] TRUE
>  max(abs(fred$gradient))
[1] 1.571989e-06
>  length(fred$r)
[1] 7
>  data.frame(type = fred$steptype, rho = fred$rho, change = fred$preddiff,
+      accept = fred$accept, r = fred$r)
       type        rho       change accept r
1 easy-easy  0.9670785 3.310155e+02   TRUE 1
2 easy-easy  0.7165275 2.588623e+02   TRUE 2
3 easy-easy  1.0316910 4.725173e+01   TRUE 2
4    Newton  0.9937390 4.463915e+00   TRUE 4
5    Newton  1.0060618 2.823699e-02   TRUE 4
6    Newton  1.0000957 2.797547e-06   TRUE 4
7    Newton -4.9010139 6.379064e-14   TRUE 4
>  (fred$stepnorm / fred$r)[fred$accept & fred$steptype != "Newton"]
[1] 1.0000000 0.9999998 0.9999999
> 
> 
>  fred <- trust(objfun, rep(-5, length(theta.true)), 1, sqrt(ncol(m)),
+      minimize = FALSE, blather = TRUE)
>  fred$converged
[1] TRUE
>  max(abs(fred$gradient))
[1] 8.921493e-07
>  length(fred$r)
[1] 16
>  data.frame(type = fred$steptype, rho = fred$rho, change = fred$preddiff,
+      accept = fred$accept, r = fred$r)
        type        rho       change accept        r
1  easy-easy  0.9999999 5.434998e+02   TRUE 1.000000
2  easy-easy  0.9999994 1.086992e+03   TRUE 2.000000
3  easy-easy  0.9999958 2.173939e+03   TRUE 4.000000
4  easy-easy  0.9999497 4.347504e+03   TRUE 8.000000
5  easy-easy  0.9993923 5.036593e+03   TRUE 9.273618
6  easy-easy  0.9744618 4.996606e+03   TRUE 9.273618
7  easy-easy  0.6009845 3.851144e+03   TRUE 9.273618
8  easy-easy  0.8177417 2.214764e+03   TRUE 9.273618
9  easy-easy -1.5163491 6.529989e+02  FALSE 9.273618
10 easy-easy  1.1352069 4.565431e+02   TRUE 2.318405
11 easy-easy  0.9371534 2.329413e+02   TRUE 4.636809
12    Newton  1.1359783 3.928266e+01   TRUE 9.273618
13    Newton  1.0595818 2.688851e+00   TRUE 9.273618
14    Newton  1.0078548 2.671281e-02   TRUE 9.273618
15    Newton  1.0001092 3.941322e-06   TRUE 9.273618
16    Newton -1.0291808 1.104634e-13   TRUE 9.273618
>  (fred$stepnorm / fred$r)[fred$accept & fred$steptype != "Newton"]
 [1] 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000 0.9999999
 [8] 0.9999999 0.9999997 1.0000000
> 
> 
